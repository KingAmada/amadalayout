<!doctype html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Urban Layout AI — Enhanced (Vanilla HTML)</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

  <!-- Lucide (UMD) -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

  <style>
    html, body { height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { touch-action: none; }
    *::-webkit-scrollbar{ width:10px; height:10px; }
    *::-webkit-scrollbar-thumb{ background:#cbd5e1; border-radius:999px; border:2px solid #f8fafc; }
    *::-webkit-scrollbar-track{ background:#f8fafc; }

    /* Street View “2.5D” look */
    .sv-persp { perspective: 900px; }
    .sv-road {
      background: linear-gradient(180deg, rgba(15,23,42,0.85), rgba(15,23,42,0.65));
      border-top: 1px dashed rgba(255,255,255,0.35);
      border-bottom: 1px dashed rgba(255,255,255,0.35);
    }
    .sv-strip {
      transform: rotateX(12deg);
      transform-origin: center top;
    }
    .sv-card {
      transform: skewX(-6deg);
    }
    .sv-card:hover {
      transform: skewX(-6deg) translateY(-2px);
    }

    /* Selection pulse */
    @keyframes pulseSoft { 0%,100%{ opacity:.35 } 50%{ opacity:.65 } }
    .pulse-soft { animation: pulseSoft 1.8s ease-in-out infinite; }

    /* Small helper */
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>

<body class="h-full overflow-hidden bg-gray-100">
  <div class="flex h-screen w-full bg-gray-100 overflow-hidden">

    <!-- SIDEBAR -->
    <div class="w-[420px] bg-white shadow-xl z-10 flex flex-col h-full border-r border-gray-200">
      <div class="p-4 border-b border-gray-200 bg-slate-50">
        <div class="flex items-center justify-between gap-3">
          <h1 class="text-xl font-bold text-slate-800 flex items-center gap-2">
            <i data-lucide="layout" class="w-6 h-6 text-blue-600"></i>
            Urban Layout AI
          </h1>
          <div class="flex items-center gap-2">
            <button id="btnExportPNG" class="px-2.5 py-1.5 text-xs font-semibold rounded bg-white border border-slate-200 hover:bg-slate-50 flex items-center gap-1.5" title="Export PNG">
              <i data-lucide="image" class="w-4 h-4"></i> PNG
            </button>
            <button id="btnExportJSON" class="px-2.5 py-1.5 text-xs font-semibold rounded bg-white border border-slate-200 hover:bg-slate-50 flex items-center gap-1.5" title="Export Layout JSON">
              <i data-lucide="download" class="w-4 h-4"></i> JSON
            </button>
            <label class="px-2.5 py-1.5 text-xs font-semibold rounded bg-white border border-slate-200 hover:bg-slate-50 flex items-center gap-1.5 cursor-pointer" title="Import Layout JSON">
              <i data-lucide="upload" class="w-4 h-4"></i> Import
              <input id="importJSON" type="file" accept="application/json" class="hidden" />
            </label>
          </div>
        </div>

        <div class="grid grid-cols-3 gap-2 mt-4">
          <button id="btnTabConfig"
            class="py-2 text-xs font-semibold rounded flex items-center justify-center gap-2 bg-blue-600 text-white shadow">
            <i data-lucide="settings" class="w-4 h-4"></i> Config
          </button>
          <button id="btnTabStats"
            class="py-2 text-xs font-semibold rounded flex items-center justify-center gap-2 bg-gray-200 text-gray-600 hover:bg-gray-300">
            <i data-lucide="info" class="w-4 h-4"></i> Analytics
          </button>
          <button id="btnTabShortlist"
            class="py-2 text-xs font-semibold rounded flex items-center justify-center gap-2 bg-gray-200 text-gray-600 hover:bg-gray-300">
            <i data-lucide="star" class="w-4 h-4"></i> Shortlist
          </button>
        </div>
      </div>

      <div class="flex-1 overflow-y-auto p-4 space-y-6">
        <!-- CONFIG TAB -->
        <div id="tabConfig" class="space-y-6">

          <!-- Quick Toggles -->
          <div class="grid grid-cols-2 gap-3">
            <label class="flex items-center justify-between gap-3 p-3 rounded border border-slate-200 bg-white">
              <div class="flex items-center gap-2">
                <i data-lucide="grid-3x3" class="w-4 h-4 text-slate-600"></i>
                <span class="text-sm font-semibold text-slate-700">Grid</span>
              </div>
              <input id="toggleGrid" type="checkbox" class="w-4 h-4 accent-blue-600" checked />
            </label>

            <label class="flex items-center justify-between gap-3 p-3 rounded border border-slate-200 bg-white">
              <div class="flex items-center gap-2">
                <i data-lucide="type" class="w-4 h-4 text-slate-600"></i>
                <span class="text-sm font-semibold text-slate-700">Labels</span>
              </div>
              <input id="toggleLabels" type="checkbox" class="w-4 h-4 accent-blue-600" checked />
            </label>

            <label class="flex items-center justify-between gap-3 p-3 rounded border border-slate-200 bg-white">
              <div class="flex items-center gap-2">
                <i data-lucide="badge-dollar-sign" class="w-4 h-4 text-slate-600"></i>
                <span class="text-sm font-semibold text-slate-700">Price</span>
              </div>
              <input id="togglePrices" type="checkbox" class="w-4 h-4 accent-blue-600" />
            </label>

            <label class="flex items-center justify-between gap-3 p-3 rounded border border-slate-200 bg-white">
              <div class="flex items-center gap-2">
                <i data-lucide="sparkles" class="w-4 h-4 text-slate-600"></i>
                <span class="text-sm font-semibold text-slate-700">Legend</span>
              </div>
              <input id="toggleLegend" type="checkbox" class="w-4 h-4 accent-blue-600" checked />
            </label>
          </div>

          <!-- Pricing Model -->
          <div class="rounded-lg border border-slate-200 bg-white overflow-hidden">
            <div class="p-3 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
              <div class="flex items-center gap-2">
                <i data-lucide="calculator" class="w-4 h-4 text-slate-700"></i>
                <span class="text-sm font-bold text-slate-800">Pricing Model</span>
              </div>
              <span class="text-xs text-slate-500">(optional)</span>
            </div>

            <div class="p-3 space-y-3">
              <div class="grid grid-cols-2 gap-3">
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Base / m²</label>
                  <input id="priceBase" type="number" class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" value="1500"/>
                </div>
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Mansion Multiplier</label>
                  <input id="priceMansionMult" type="number" step="0.05" class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" value="1.35"/>
                </div>
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Amenity Bonus (max)</label>
                  <input id="priceAmenityBonus" type="number" step="0.01" class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" value="0.18"/>
                </div>
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Boulevard Bonus (max)</label>
                  <input id="priceRoadBonus" type="number" step="0.01" class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" value="0.12"/>
                </div>
              </div>

              <div class="flex items-center justify-between gap-3 p-2 rounded border border-slate-200 bg-slate-50">
                <div class="text-xs text-slate-600">
                  Price labels appear when you zoom in.
                </div>
                <button id="btnResetPricing" class="px-2.5 py-1.5 text-xs font-semibold rounded bg-white border border-slate-200 hover:bg-slate-100">
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- DIMENSIONS -->
          <div class="space-y-3">
            <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i data-lucide="map" class="w-3 h-3"></i> Infrastructure (Meters)
            </h3>

            <div class="grid grid-cols-2 gap-3">
              <div class="flex flex-col">
                <label class="text-xs text-slate-500 mb-1">Main Blvd Width</label>
                <input id="mainRoadWidth" type="number"
                  class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
              </div>
              <div class="flex flex-col">
                <label class="text-xs text-slate-500 mb-1">Res. Street Width</label>
                <input id="resStreetWidth" type="number"
                  class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
              </div>
              <div class="flex flex-col col-span-2">
                <label class="text-xs text-slate-500 mb-1">Res. Roundabout R</label>
                <input id="resRoundaboutRadius" type="number"
                  class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
              </div>
            </div>
          </div>

          <div class="h-px bg-gray-200"></div>

          <div class="space-y-3">
            <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i data-lucide="home" class="w-3 h-3"></i> Housing Units (Meters)
            </h3>

            <div class="mb-4">
              <span class="text-xs font-semibold text-blue-600 block mb-2">Standard Row House</span>
              <div class="grid grid-cols-2 gap-3">
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Frontage (Width)</label>
                  <input id="houseWidth" type="number"
                    class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
                </div>
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Depth (Length)</label>
                  <input id="houseDepth" type="number"
                    class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
                </div>
              </div>
            </div>

            <div class="p-3 bg-purple-50 rounded border border-purple-100">
              <span class="text-xs font-semibold text-purple-700 block mb-2 flex items-center gap-1">
                <i data-lucide="crown" class="w-3 h-3"></i> Street-End Maisonette
              </span>
              <div class="grid grid-cols-2 gap-3">
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Width</label>
                  <input id="mansionWidth" type="number"
                    class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
                </div>
                <div class="flex flex-col">
                  <label class="text-xs text-slate-500 mb-1">Depth</label>
                  <input id="mansionDepth" type="number"
                    class="w-full border border-gray-300 rounded px-2 py-1 text-sm focus:border-blue-500 outline-none" />
                </div>
              </div>
            </div>
          </div>

          <div class="h-px bg-gray-200"></div>

          <div class="space-y-3">
            <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i data-lucide="building-2" class="w-3 h-3"></i> Amenities (Width x Length)
            </h3>

            <div id="amenitiesRows" class="space-y-2"></div>
          </div>

          <!-- Legend -->
          <div id="legendBox" class="rounded-lg border border-slate-200 bg-white overflow-hidden">
            <div class="p-3 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
              <div class="flex items-center gap-2">
                <i data-lucide="sparkles" class="w-4 h-4 text-slate-700"></i>
                <span class="text-sm font-bold text-slate-800">Legend</span>
              </div>
              <span class="text-xs text-slate-500">Zoning</span>
            </div>
            <div class="p-3 grid grid-cols-2 gap-2 text-xs">
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#bfdbfe"></span> Row Houses</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#c4b5fd"></span> Mansions</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#374151"></span> Roads/Parking</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#fca5a5"></span> Mall/Commercial</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#fde68a"></span> Resort</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#ddd6fe"></span> School</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#86efac"></span> Park/Golf</div>
              <div class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background:#7dd3fc"></span> Lagoon/Water</div>
            </div>
          </div>

        </div>

        <!-- ANALYTICS TAB -->
        <div id="tabStats" class="space-y-6 hidden">
          <div class="space-y-3">
            <h2 class="text-sm font-semibold text-slate-400 uppercase tracking-wider">Land Usage</h2>
            <div id="statsBars" class="space-y-3"></div>
          </div>

          <!-- Metrics -->
          <div class="rounded-lg border border-slate-200 bg-white overflow-hidden">
            <div class="p-3 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
              <div class="flex items-center gap-2">
                <i data-lucide="activity" class="w-4 h-4 text-slate-700"></i>
                <span class="text-sm font-bold text-slate-800">Estate Metrics</span>
              </div>
              <span class="text-xs text-slate-500">Auto</span>
            </div>
            <div class="p-3 grid grid-cols-2 gap-3 text-sm">
              <div class="p-3 rounded border border-slate-200 bg-white">
                <div class="text-xs text-slate-500">Row Houses</div>
                <div id="mRowHouses" class="text-lg font-extrabold text-slate-900">—</div>
              </div>
              <div class="p-3 rounded border border-slate-200 bg-white">
                <div class="text-xs text-slate-500">Mansions</div>
                <div id="mMansions" class="text-lg font-extrabold text-slate-900">—</div>
              </div>
              <div class="p-3 rounded border border-slate-200 bg-white">
                <div class="text-xs text-slate-500">Road Length (est.)</div>
                <div id="mRoadLen" class="text-lg font-extrabold text-slate-900">—</div>
              </div>
              <div class="p-3 rounded border border-slate-200 bg-white">
                <div class="text-xs text-slate-500">Amenity Area</div>
                <div id="mAmenityArea" class="text-lg font-extrabold text-slate-900">—</div>
              </div>
              <div class="p-3 rounded border border-slate-200 bg-white col-span-2">
                <div class="text-xs text-slate-500">Warnings (Boundary / Overlap)</div>
                <div id="mWarnings" class="mt-2 text-xs text-slate-700 space-y-1"></div>
              </div>
            </div>
          </div>

          <!-- Inspector + Selection -->
          <div class="bg-slate-50 rounded-lg p-4 border border-slate-200">
            <div class="flex items-center justify-between gap-2">
              <h2 class="text-sm font-semibold text-slate-800 flex items-center gap-2">
                <i data-lucide="info" class="w-4 h-4"></i> Inspector
              </h2>
              <div class="flex items-center gap-2">
                <button id="btnClearSelection" class="px-2.5 py-1.5 text-xs font-semibold rounded bg-white border border-slate-200 hover:bg-slate-100">
                  Clear
                </button>
              </div>
            </div>

            <div id="inspectorEmpty" class="text-slate-400 text-sm italic mt-3">
              Hover over the map to inspect lots, roads, and buildings.
            </div>

            <div id="inspectorFilled" class="space-y-2 text-sm hidden mt-3">
              <div class="flex justify-between">
                <span class="text-slate-500">Name:</span>
                <span id="insName" class="font-medium text-blue-700"></span>
              </div>
              <div class="flex justify-between">
                <span class="text-slate-500">Type:</span>
                <span id="insType" class="capitalize"></span>
              </div>
              <div class="flex justify-between">
                <span class="text-slate-500">Dimensions:</span>
                <span id="insDim" class="mono text-xs text-slate-700"></span>
              </div>
              <div class="flex justify-between items-center bg-blue-50 p-2 rounded border border-blue-100 mt-2">
                <span class="text-blue-800 font-semibold">Total Area:</span>
                <span id="insArea" class="mono font-bold text-blue-900"></span>
              </div>

              <div class="grid grid-cols-2 gap-2 mt-3">
                <button id="btnToggleFavorite" class="px-3 py-2 text-xs font-bold rounded bg-white border border-slate-200 hover:bg-slate-100 flex items-center justify-center gap-2">
                  <i data-lucide="star" class="w-4 h-4"></i> Favorite
                </button>
                <button id="btnPinSelection" class="px-3 py-2 text-xs font-bold rounded bg-slate-900 text-white hover:bg-slate-800 flex items-center justify-center gap-2">
                  <i data-lucide="pin" class="w-4 h-4"></i> Pin/Compare
                </button>
                <button id="btnOpenFloorplan" class="px-3 py-2 text-xs font-bold rounded bg-blue-600 text-white hover:bg-blue-700 flex items-center justify-center gap-2 col-span-2">
                  <i data-lucide="scan" class="w-4 h-4"></i> Open Floor Plan
                </button>
              </div>

              <div class="mt-4">
                <div class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">Pinned Compare (max 3)</div>
                <div id="compareList" class="space-y-2"></div>
              </div>

              <div class="mt-3 text-xs text-slate-500 italic">
                Tip: Click roads to open <span class="font-semibold">Street View</span>.
              </div>
            </div>
          </div>
        </div>

        <!-- SHORTLIST TAB -->
        <div id="tabShortlist" class="space-y-4 hidden">
          <div class="rounded-lg border border-slate-200 bg-white overflow-hidden">
            <div class="p-3 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
              <div class="flex items-center gap-2">
                <i data-lucide="star" class="w-4 h-4 text-slate-700"></i>
                <span class="text-sm font-bold text-slate-800">Favorites</span>
              </div>
              <button id="btnClearFavorites" class="text-xs font-semibold text-slate-600 hover:text-slate-900">
                Clear
              </button>
            </div>
            <div class="p-3">
              <div id="favoritesList" class="space-y-2"></div>
              <div id="favoritesEmpty" class="text-sm text-slate-400 italic">No favorites yet. Star a unit in Inspector.</div>
            </div>
          </div>

          <div class="rounded-lg border border-slate-200 bg-white overflow-hidden">
            <div class="p-3 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
              <div class="flex items-center gap-2">
                <i data-lucide="layers" class="w-4 h-4 text-slate-700"></i>
                <span class="text-sm font-bold text-slate-800">Actions</span>
              </div>
            </div>
            <div class="p-3 grid grid-cols-2 gap-2">
              <button id="btnFit" class="px-3 py-2 text-xs font-bold rounded bg-white border border-slate-200 hover:bg-slate-100 flex items-center justify-center gap-2">
                <i data-lucide="maximize-2" class="w-4 h-4"></i> Fit Boundary
              </button>
              <button id="btnResetView" class="px-3 py-2 text-xs font-bold rounded bg-white border border-slate-200 hover:bg-slate-100 flex items-center justify-center gap-2">
                <i data-lucide="refresh-ccw" class="w-4 h-4"></i> Reset View
              </button>
              <button id="btnToggleStreetViewHint" class="px-3 py-2 text-xs font-bold rounded bg-slate-900 text-white hover:bg-slate-800 flex items-center justify-center gap-2 col-span-2">
                <i data-lucide="car" class="w-4 h-4"></i> Street View Mode (Click Roads)
              </button>
            </div>
          </div>

          <div class="text-xs text-slate-500 leading-relaxed">
            <div class="font-bold text-slate-700 mb-1">Keyboard</div>
            <div>W/A/S/D or Arrow Keys: Pan</div>
            <div>+ / - : Zoom</div>
            <div>F : Fit boundary</div>
            <div>R : Reset</div>
            <div>Esc : Close modals</div>
          </div>
        </div>

      </div>
    </div>

    <!-- MAIN VIEWPORT -->
    <div class="flex-1 relative bg-slate-200 overflow-hidden cursor-move">
      <canvas id="mapCanvas" width="2400" height="3000" class="w-full h-full"></canvas>

      <!-- MINI MAP -->
      <div class="absolute bottom-4 right-4 w-[240px] select-none">
        <div class="bg-white/95 backdrop-blur rounded-xl shadow border border-slate-200 overflow-hidden">
          <div class="px-3 py-2 border-b border-slate-200 bg-slate-50 flex items-center justify-between">
            <div class="text-xs font-bold text-slate-700 flex items-center gap-2">
              <i data-lucide="map" class="w-4 h-4"></i> Mini Map
            </div>
            <div class="text-[11px] text-slate-500">drag to move</div>
          </div>
          <canvas id="miniMap" width="240" height="180" class="w-full h-[180px]"></canvas>
        </div>
      </div>

      <!-- OVERLAY CONTROLS -->
      <div class="absolute top-4 right-4 flex flex-col gap-2">
        <button id="btnZoomIn" class="p-2 bg-white rounded shadow hover:bg-gray-50" title="Zoom In">
          <i data-lucide="zoom-in" class="w-5 h-5"></i>
        </button>
        <button id="btnZoomOut" class="p-2 bg-white rounded shadow hover:bg-gray-50" title="Zoom Out">
          <i data-lucide="zoom-out" class="w-5 h-5"></i>
        </button>
        <button id="btnFitTop" class="p-2 bg-white rounded shadow hover:bg-gray-50" title="Fit Boundary">
          <i data-lucide="maximize-2" class="w-5 h-5"></i>
        </button>
        <button id="btnReset" class="p-2 bg-white rounded shadow hover:bg-gray-50" title="Reset View">
          <i data-lucide="maximize" class="w-5 h-5"></i>
        </button>
      </div>

      <div class="absolute bottom-4 left-4 bg-white/90 backdrop-blur px-3 py-2 rounded shadow text-xs text-slate-600 pointer-events-none">
        <div class="font-semibold text-slate-800">Tips</div>
        <div>Scroll: zoom • Drag: pan • Drag car: scale check</div>
        <div>Click lots: pin/compare • Click roads: Street View</div>
      </div>

      <!-- MODAL ROOT -->
      <div id="modalRoot" class="absolute inset-0 hidden"></div>

      <!-- STREET VIEW ROOT -->
      <div id="streetViewRoot" class="absolute inset-0 hidden"></div>
    </div>
  </div>

<script>
(() => {
  // --- CONSTANTS & CONFIGURATION ---
  const LAND_WIDTH_M = 280;
  const LAND_HEIGHT_M = 420;

  const BOUNDARY = {
    tl: { x: 10, y: 10 },
    tr: { x: 257, y: 10 },
    br: { x: 230, y: 409 },
    bl: { x: 10, y: 377 }
  };

  const TOTAL_AREA_SQM = 93000;

  const COLORS = {
    grass: '#f0fdf4',
    boundary: '#15803d',
    road: '#374151',
    roadMarking: '#f3f4f6',
    residential: '#bfdbfe',
    residentialHighlight: '#60a5fa',
    mansion: '#c4b5fd',
    mansionHighlight: '#a78bfa',
    commercial: '#fca5a5',
    commercialHighlight: '#f87171',
    resort: '#fde68a',
    school: '#ddd6fe',
    park: '#86efac',
    water: '#7dd3fc',
    car: '#ef4444'
  };

  const STORAGE_KEY = "urbanLayoutAI_enhanced_v1";
  const BUFFER_PPM = 6; // pixels per meter for cached layers
  const LABEL_ZOOM_THRESHOLD = 2.25;
  const PRICE_ZOOM_THRESHOLD = 2.45;

  // --- HELPER CLASSES ---
  class Rectangle {
    constructor(x, y, w, h, type, label, details = {}) {
      this.x = x; this.y = y; this.w = w; this.h = h;
      this.type = type; this.label = label; this.details = details;
    }
    contains(mx, my) {
      return mx >= this.x && mx <= this.x + this.w && my >= this.y && my <= this.y + this.h;
    }
    center() {
      return { x: this.x + this.w / 2, y: this.y + this.h / 2 };
    }
  }

  // --- DOM ---
  const canvas = document.getElementById('mapCanvas');
  const ctx = canvas.getContext('2d');

  const mini = document.getElementById('miniMap');
  const miniCtx = mini.getContext('2d');

  const amenitiesRows = document.getElementById('amenitiesRows');
  const statsBars = document.getElementById('statsBars');
  const modalRoot = document.getElementById('modalRoot');
  const streetViewRoot = document.getElementById('streetViewRoot');

  // Tabs
  const tabConfig = document.getElementById('tabConfig');
  const tabStats = document.getElementById('tabStats');
  const tabShortlist = document.getElementById('tabShortlist');

  const btnTabConfig = document.getElementById('btnTabConfig');
  const btnTabStats = document.getElementById('btnTabStats');
  const btnTabShortlist = document.getElementById('btnTabShortlist');

  // Analytics UI
  const mRowHouses = document.getElementById('mRowHouses');
  const mMansions = document.getElementById('mMansions');
  const mRoadLen = document.getElementById('mRoadLen');
  const mAmenityArea = document.getElementById('mAmenityArea');
  const mWarnings = document.getElementById('mWarnings');

  const inspectorEmpty = document.getElementById('inspectorEmpty');
  const inspectorFilled = document.getElementById('inspectorFilled');
  const insName = document.getElementById('insName');
  const insType = document.getElementById('insType');
  const insDim = document.getElementById('insDim');
  const insArea = document.getElementById('insArea');
  const compareList = document.getElementById('compareList');

  // Shortlist UI
  const favoritesList = document.getElementById('favoritesList');
  const favoritesEmpty = document.getElementById('favoritesEmpty');
  const legendBox = document.getElementById('legendBox');

  // --- STATE ---
  let scale = 1.8;
  let offset = { x: 40, y: 40 };
  let hoveredItem = null;

  let showGrid = true;
  let showLabels = true;
  let showPrices = false;
  let showLegend = true;

  let carPosition = { x: 140, y: 380, rotation: 0 };
  let isDraggingCar = false;
  let isPanning = false;
  let lastMousePos = { x: 0, y: 0 };
  let clickStartPos = { x: 0, y: 0 };

  let activeTab = 'config';

  // Pinned compare (max 3)
  /** @type {Rectangle[]} */
  let pinned = [];

  // Favorites (by label)
  let favorites = new Set();

  // Street view
  let streetViewOpen = false;
  let streetViewRoad = null;
  let streetViewCarT = 0;

  // Pricing model
  let pricing = {
    basePerSqm: 1500,
    mansionMult: 1.35,
    amenityBonusMax: 0.18,
    roadBonusMax: 0.12
  };

  // Layout + stats + warnings
  /** @type {Rectangle[]} */
  let layoutData = [];
  let stats = { residential: 0, road: 0, commercial: 0, green: 0, public: 0 };
  let warnings = [];

  // Derived layout metadata
  let layoutMeta = {
    mainBoulevard: null,
    amenities: []
  };

  // --- CONFIG ---
  let config = {
    mainRoadWidth: 16,
    resStreetWidth: 12,
    resRoundaboutRadius: 8,

    houseWidth: 15,
    houseDepth: 18,

    mansionWidth: 22,
    mansionDepth: 25,

    waterWidth: 90,
    waterDepth: 80,

    resortWidth: 90,
    resortDepth: 50,

    parkWidth: 90,
    parkDepth: 90,

    schoolWidth: 90,
    schoolDepth: 40,

    mallWidth: 90,
    mallDepth: 60,

    mallParkingWidth: 90,
    mallParkingDepth: 20
  };

  // --- CACHED LAYERS (buffers) ---
  const bufStatic = document.createElement('canvas');
  const bufRoads  = document.createElement('canvas');
  const bufLots   = document.createElement('canvas');
  const bufAmen   = document.createElement('canvas');

  function initBuffers() {
    const w = Math.ceil(LAND_WIDTH_M * BUFFER_PPM);
    const h = Math.ceil(LAND_HEIGHT_M * BUFFER_PPM);
    [bufStatic, bufRoads, bufLots, bufAmen].forEach(b => {
      b.width = w; b.height = h;
    });
  }

  // --- BOUNDARY MATH ---
  function getRightBoundaryX(y) {
    const x1 = BOUNDARY.tr.x, y1 = BOUNDARY.tr.y;
    const x2 = BOUNDARY.br.x, y2 = BOUNDARY.br.y;
    return x1 + (y - y1) * (x2 - x1) / (y2 - y1);
  }

  function getBottomBoundaryY(x) {
    const x1 = BOUNDARY.bl.x, y1 = BOUNDARY.bl.y;
    const x2 = BOUNDARY.br.x, y2 = BOUNDARY.br.y;
    if (x2 === x1) return y1;
    return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
  }

  const boundaryPoly = [
    [BOUNDARY.tl.x, BOUNDARY.tl.y],
    [BOUNDARY.tr.x, BOUNDARY.tr.y],
    [BOUNDARY.br.x, BOUNDARY.br.y],
    [BOUNDARY.bl.x, BOUNDARY.bl.y],
  ];

  function pointInPoly(x, y, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function rectCorners(r) {
    return [
      {x:r.x, y:r.y},
      {x:r.x+r.w, y:r.y},
      {x:r.x+r.w, y:r.y+r.h},
      {x:r.x, y:r.y+r.h},
    ];
  }

  function rectsOverlap(a, b) {
    const xOverlap = Math.min(a.x + a.w, b.x + b.w) - Math.max(a.x, b.x);
    const yOverlap = Math.min(a.y + a.h, b.y + b.h) - Math.max(a.y, b.y);
    return (xOverlap > 0.15 && yOverlap > 0.15);
  }

  // --- LAYOUT GENERATION ---
  function computeLayoutData() {
    const elements = [];

    const mainRoadWidth = Number(config.mainRoadWidth);
    const houseWidth = Number(config.houseWidth);
    const houseDepth = Number(config.houseDepth);
    const resStreetWidth = Number(config.resStreetWidth);
    const mansionWidth = Number(config.mansionWidth);
    const mansionDepth = Number(config.mansionDepth);

    const leftMargin = 5;
    const requiredHousingWidth = mansionWidth + 5 + (7 * houseWidth);
    const maxMainRoadX = 220;
    const calculatedMainRoadX = leftMargin + requiredHousingWidth + 5;
    const mainRoadX = Math.min(maxMainRoadX, Math.max(140, calculatedMainRoadX));

    const mainRoadHeight = getBottomBoundaryY(mainRoadX + mainRoadWidth / 2) - 10;
    elements.push(new Rectangle(mainRoadX, 10, mainRoadWidth, mainRoadHeight, 'road', 'Main Boulevard', { width: mainRoadWidth, zoning: 'road', isMain: true }));

    // Residential
    const resZoneCenterX = (leftMargin + mainRoadX) / 2;
    const resZoneBottomY = getBottomBoundaryY(resZoneCenterX);
    const resZoneTopY = 20;
    const availableResHeight = resZoneBottomY - resZoneTopY;

    const rowHouseBlockHeight = (houseDepth * 2) + resStreetWidth;
    const singleBlockHeight = Math.max(rowHouseBlockHeight, mansionDepth);
    const totalRequiredHeight = 5 * singleBlockHeight;

    let blockGap = 10;
    if (totalRequiredHeight > availableResHeight) blockGap = 0;
    else blockGap = (availableResHeight - totalRequiredHeight) / 6;

    const raboutRadius = Number(config.resRoundaboutRadius);

    for (let i = 0; i < 5; i++) {
      const blockStartY = resZoneTopY + blockGap + (i * (singleBlockHeight + blockGap));
      const streetY = blockStartY + houseDepth;
      if (blockStartY + singleBlockHeight > resZoneBottomY) break;

      // Roundabout
      elements.push(
        new Rectangle(
          mainRoadX - raboutRadius + mainRoadWidth / 2,
          streetY + resStreetWidth / 2 - raboutRadius,
          raboutRadius * 2,
          raboutRadius * 2,
          'roundabout',
          `Circle ${i + 1}`,
          { radius: raboutRadius, zoning: 'road' }
        )
      );

      // Mansion
      const streetCenterY = streetY + resStreetWidth / 2;
      const mansionY = streetCenterY - (mansionDepth / 2);
      elements.push(new Rectangle(leftMargin, mansionY, mansionWidth, mansionDepth, 'mansion', `Mansion ${i + 1}`, {
        zoning: 'residential',
        area: mansionWidth * mansionDepth,
        dim: `${mansionWidth}x${mansionDepth}m`
      }));

      // Street
      const streetStartX = leftMargin + mansionWidth;
      const streetEndX = mainRoadX - raboutRadius + mainRoadWidth / 2;
      elements.push(new Rectangle(streetStartX, streetY, streetEndX - streetStartX, resStreetWidth, 'road', `Residential St ${i + 1}`, {
        width: resStreetWidth,
        zoning: 'road',
        streetIndex: i + 1
      }));

      // Houses rows
      const rowHouseStartX = streetStartX + 2;

      for (let h = 0; h < 7; h++) {
        const hx = rowHouseStartX + (h * houseWidth);
        if (hx + houseWidth > streetEndX - 2) break;
        elements.push(new Rectangle(hx + 1, blockStartY, houseWidth - 2, houseDepth, 'lot', `Unit ${i + 1}A-${h + 1}`, {
          zoning: 'residential',
          area: (houseWidth - 2) * houseDepth,
          dim: `${houseWidth - 2}x${houseDepth}m`,
          street: `Residential St ${i + 1}`,
          row: 'A'
        }));
      }
      for (let h = 0; h < 7; h++) {
        const hx = rowHouseStartX + (h * houseWidth);
        if (hx + houseWidth > streetEndX - 2) break;
        elements.push(new Rectangle(hx + 1, streetY + resStreetWidth, houseWidth - 2, houseDepth, 'lot', `Unit ${i + 1}B-${h + 1}`, {
          zoning: 'residential',
          area: (houseWidth - 2) * houseDepth,
          dim: `${houseWidth - 2}x${houseDepth}m`,
          street: `Residential St ${i + 1}`,
          row: 'B'
        }));
      }
    }

    // Amenities
    const rightZoneX = mainRoadX + mainRoadWidth;
    const amTopY = 20;
    const amBottomY = getBottomBoundaryY(rightZoneX + 40) - 10;
    const availableAmHeight = amBottomY - amTopY;

    const dims = [
      { h: Number(config.waterDepth), w: Number(config.waterWidth), type: 'water', label: 'Lagoon', zoning: 'water', icon: 'waves' },
      { h: Number(config.resortDepth), w: Number(config.resortWidth), type: 'building', label: 'Resort', zoning: 'resort', icon: 'umbrella' },
      { h: Number(config.parkDepth), w: Number(config.parkWidth), type: 'park', label: 'Park/Golf', zoning: 'park', icon: 'trees' },
      { h: Number(config.schoolDepth), w: Number(config.schoolWidth), type: 'building', label: 'School', zoning: 'school', icon: 'graduation-cap' },
      { h: Number(config.mallDepth), w: Number(config.mallWidth), type: 'building', label: 'Mall', zoning: 'commercial', icon: 'shopping-bag' },
      { h: Number(config.mallParkingDepth), w: Number(config.mallParkingWidth), type: 'road', label: 'Parking', zoning: 'parking', icon: 'parking-square' }
    ];

    const totalAmHeight = dims.reduce((acc, d) => acc + d.h, 0);
    let amGap = 10;
    if (totalAmHeight > availableAmHeight) amGap = 0;
    else amGap = (availableAmHeight - totalAmHeight) / 5;

    let currentY = amTopY;
    dims.forEach(d => {
      const currentMaxX = getRightBoundaryX(currentY + d.h / 2);
      const availableW = (currentMaxX - rightZoneX) - 5;
      const finalW = Math.min(d.w, availableW);

      const rect = new Rectangle(rightZoneX + 2, currentY, finalW, d.h, d.type, d.label, {
        zoning: d.zoning,
        area: finalW * d.h,
        icon: d.icon
      });

      // deterministic park dots
      if (d.type === 'park') {
        const dots = [];
        const seed = Math.floor((rect.x + rect.y + rect.w + rect.h) * 10);
        let s = seed;
        function rnd() { s = (s * 1664525 + 1013904223) >>> 0; return (s / 4294967296); }
        for (let i = 0; i < 18; i++) dots.push({ x: rect.x + rnd() * rect.w, y: rect.y + rnd() * rect.h });
        rect.details.treeDots = dots;
      }

      elements.push(rect);
      currentY += d.h + amGap;
    });

    return elements;
  }

  function computeStats() {
    const s = { residential: 0, road: 0, commercial: 0, green: 0, public: 0 };
    layoutData.forEach(el => {
      const area = el.w * el.h;
      if (el.type === 'lot' || el.type === 'mansion') s.residential += area;
      else if (el.type === 'road' || el.type === 'roundabout') s.road += area;
      else if (el.details.zoning === 'commercial' || el.details.zoning === 'resort') s.commercial += area;
      else if (el.details.zoning === 'school') s.public += area;
      else if (el.type === 'park' || el.type === 'water') s.green += area;
    });
    return s;
  }

  function deriveLayoutMeta() {
    layoutMeta.mainBoulevard = layoutData.find(x => x.type === 'road' && x.label === 'Main Boulevard') || null;
    layoutMeta.amenities = layoutData.filter(x => ['water','park','building'].includes(x.type) && x.details && x.details.zoning && x.details.zoning !== 'residential');
  }

  function computeWarnings() {
    const w = [];
    // Boundary checks for non-road features (and amenities)
    layoutData.forEach(el => {
      if (el.type === 'lot' || el.type === 'mansion' || el.type === 'building' || el.type === 'park' || el.type === 'water') {
        const corners = rectCorners(el);
        const outside = corners.some(p => !pointInPoly(p.x, p.y, boundaryPoly));
        if (outside) w.push(`⚠️ ${el.label}: exceeds boundary`);
      }
    });

    // Overlap checks (ignore road/roundabout vs others, allow roads overlap roundabouts)
    const check = layoutData.filter(el => el.type !== 'roundabout');
    for (let i = 0; i < check.length; i++) {
      for (let j = i + 1; j < check.length; j++) {
        const a = check[i], b = check[j];
        const ignore =
          (a.type === 'road' || b.type === 'road') || // allow roads to touch others
          (a.type === 'water' && b.type === 'park') || // doesn’t happen but just in case
          false;
        if (ignore) continue;

        if (rectsOverlap(a, b)) {
          // ignore mansion vs lot overlaps if they never happen—still warn if it does
          w.push(`⚠️ Overlap: ${a.label} ↔ ${b.label}`);
        }
      }
    }

    return w.slice(0, 12); // keep UI clean
  }

  // --- PRICING ---
  function distance(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx, dy);
  }

  function clamp01(v){ return Math.max(0, Math.min(1, v)); }

  function estimatePrice(lot) {
    if (!(lot.type === 'lot' || lot.type === 'mansion')) return null;
    const area = lot.w * lot.h;
    let mult = 1;

    if (lot.type === 'mansion') mult *= pricing.mansionMult;

    // Road bonus: closer to main boulevard centerline = higher
    if (layoutMeta.mainBoulevard) {
      const mb = layoutMeta.mainBoulevard;
      const mbCenter = { x: mb.x + mb.w/2, y: lot.center().y };
      const d = Math.abs(lot.center().x - mbCenter.x);
      const maxD = 120; // roughly left-to-right span
      const bonus = pricing.roadBonusMax * (1 - clamp01(d / maxD));
      mult *= (1 + bonus);
    }

    // Amenity bonus: closer to nearest amenity center = higher
    if (layoutMeta.amenities.length) {
      const lc = lot.center();
      let best = Infinity;
      for (const am of layoutMeta.amenities) {
        const dc = distance(lc, am.center());
        best = Math.min(best, dc);
      }
      const maxD = 180; // decay distance
      const bonus = pricing.amenityBonusMax * (1 - clamp01(best / maxD));
      mult *= (1 + bonus);
    }

    const price = area * pricing.basePerSqm * mult;
    return Math.round(price);
  }

  function fmtMoney(n) {
    if (n == null) return "—";
    // generic currency formatting
    return n.toLocaleString(undefined, { maximumFractionDigits: 0 });
  }

  // --- CACHED LAYER DRAWING ---
  function drawBoundaryAndLabels(bctx) {
    // Boundary
    bctx.beginPath();
    bctx.moveTo(BOUNDARY.tl.x, BOUNDARY.tl.y);
    bctx.lineTo(BOUNDARY.tr.x, BOUNDARY.tr.y);
    bctx.lineTo(BOUNDARY.br.x, BOUNDARY.br.y);
    bctx.lineTo(BOUNDARY.bl.x, BOUNDARY.bl.y);
    bctx.closePath();

    bctx.fillStyle = COLORS.grass;
    bctx.fill();
    bctx.strokeStyle = COLORS.boundary;
    bctx.lineWidth = 1.5;
    bctx.stroke();

    // Dimension labels
    bctx.fillStyle = '#166534';
    bctx.font = '4px Arial';
    bctx.fillText('Back: 247m', 120, 8);
    bctx.fillText('Front: 207m', 100, 415);

    bctx.save();
    bctx.translate(5, 200);
    bctx.rotate(-Math.PI / 2);
    bctx.fillText('Side: 367m', 0, 0);
    bctx.restore();

    bctx.save();
    bctx.translate(265, 200);
    bctx.rotate(Math.PI / 2);
    bctx.fillText('Side: 399m', 0, 0);
    bctx.restore();
  }

  function rebuildCaches() {
    // Static: grass + boundary + labels + grid
    const sctx = bufStatic.getContext('2d');
    sctx.setTransform(1,0,0,1,0,0);
    sctx.clearRect(0,0,bufStatic.width, bufStatic.height);
    sctx.save();
    sctx.scale(BUFFER_PPM, BUFFER_PPM);

    drawBoundaryAndLabels(sctx);

    if (showGrid) {
      sctx.beginPath();
      sctx.strokeStyle = '#d1d5db';
      sctx.lineWidth = 0.1;
      for (let i = 0; i <= LAND_WIDTH_M; i += 10) { sctx.moveTo(i, 0); sctx.lineTo(i, LAND_HEIGHT_M); }
      for (let i = 0; i <= LAND_HEIGHT_M; i += 10) { sctx.moveTo(0, i); sctx.lineTo(LAND_WIDTH_M, i); }
      sctx.stroke();
    }

    sctx.restore();

    // Roads layer
    const rctx = bufRoads.getContext('2d');
    rctx.setTransform(1,0,0,1,0,0);
    rctx.clearRect(0,0,bufRoads.width, bufRoads.height);
    rctx.save();
    rctx.scale(BUFFER_PPM, BUFFER_PPM);

    layoutData.forEach(el => {
      if (el.type === 'road') {
        rctx.fillStyle = COLORS.road;
        rctx.fillRect(el.x, el.y, el.w, el.h);

        // dashed marking
        rctx.beginPath();
        rctx.strokeStyle = COLORS.roadMarking;
        rctx.setLineDash([2, 4]);
        rctx.lineWidth = 0.3;

        if (el.w > el.h) {
          rctx.moveTo(el.x, el.y + el.h / 2);
          rctx.lineTo(el.x + el.w, el.y + el.h / 2);
        } else {
          rctx.moveTo(el.x + el.w / 2, el.y);
          rctx.lineTo(el.x + el.w / 2, el.y + el.h);
        }
        rctx.stroke();
        rctx.setLineDash([]);

        // street label on roads (subtle, only in cache)
        rctx.save();
        rctx.globalAlpha = 0.18;
        rctx.fillStyle = '#fff';
        rctx.font = '4px Arial';
        rctx.textAlign = 'center';
        rctx.fillText(el.label, el.x + el.w/2, el.y + el.h/2);
        rctx.restore();
      }
      if (el.type === 'roundabout') {
        rctx.fillStyle = COLORS.road;
        rctx.beginPath();
        const r = el.w / 2;
        rctx.arc(el.x + r, el.y + r, r, 0, Math.PI * 2);
        rctx.fill();

        rctx.fillStyle = COLORS.grass;
        rctx.beginPath();
        rctx.arc(el.x + r, el.y + r, r * 0.4, 0, Math.PI * 2);
        rctx.fill();
      }
    });

    rctx.restore();

    // Lots layer (rowhouses + mansions base)
    const lctx = bufLots.getContext('2d');
    lctx.setTransform(1,0,0,1,0,0);
    lctx.clearRect(0,0,bufLots.width, bufLots.height);
    lctx.save();
    lctx.scale(BUFFER_PPM, BUFFER_PPM);

    layoutData.forEach(el => {
      if (el.type === 'lot') {
        // base
        lctx.fillStyle = COLORS.residential;
        lctx.fillRect(el.x, el.y, el.w, el.h);

        // house detailing: roof band + driveway + frontage line
        // roof band (top)
        lctx.fillStyle = 'rgba(15,23,42,0.10)';
        lctx.fillRect(el.x, el.y, el.w, Math.min(2.2, el.h * 0.12));

        // driveway (front edge near road): assume front is bottom side
        lctx.fillStyle = 'rgba(0,0,0,0.12)';
        lctx.fillRect(el.x + el.w * 0.08, el.y + el.h * 0.82, el.w * 0.28, el.h * 0.14);

        // inner “courtyard”
        lctx.fillStyle = 'rgba(255,255,255,0.72)';
        const margin = 2;
        if (el.w > margin*2 && el.h > margin*2) {
          lctx.fillRect(el.x + margin, el.y + margin, el.w - margin*2, el.h - margin*2);
        }

        // frontage line
        lctx.strokeStyle = 'rgba(15,23,42,0.18)';
        lctx.lineWidth = 0.35;
        lctx.beginPath();
        lctx.moveTo(el.x, el.y + el.h);
        lctx.lineTo(el.x + el.w, el.y + el.h);
        lctx.stroke();

      } else if (el.type === 'mansion') {
        lctx.fillStyle = COLORS.mansion;
        lctx.fillRect(el.x, el.y, el.w, el.h);

        // roof cross
        lctx.beginPath();
        lctx.strokeStyle = 'rgba(0,0,0,0.12)';
        lctx.lineWidth = 0.5;
        lctx.moveTo(el.x, el.y);
        lctx.lineTo(el.x + el.w, el.y + el.h);
        lctx.moveTo(el.x + el.w, el.y);
        lctx.lineTo(el.x, el.y + el.h);
        lctx.stroke();

        // driveway hint
        lctx.fillStyle = 'rgba(0,0,0,0.10)';
        lctx.fillRect(el.x + el.w*0.05, el.y + el.h*0.78, el.w*0.35, el.h*0.18);

        // subtle border
        lctx.strokeStyle = 'rgba(15,23,42,0.12)';
        lctx.lineWidth = 0.5;
        lctx.strokeRect(el.x, el.y, el.w, el.h);
      }
    });

    lctx.restore();

    // Amenities layer
    const actx = bufAmen.getContext('2d');
    actx.setTransform(1,0,0,1,0,0);
    actx.clearRect(0,0,bufAmen.width, bufAmen.height);
    actx.save();
    actx.scale(BUFFER_PPM, BUFFER_PPM);

    layoutData.forEach(el => {
      if (el.type === 'building') {
        const isCommercial = el.details.zoning === 'commercial';
        const isSchool = el.details.zoning === 'school';
        const isResort = el.details.zoning === 'resort';

        if (isCommercial) actx.fillStyle = COLORS.commercial;
        if (isSchool) actx.fillStyle = COLORS.school;
        if (isResort) actx.fillStyle = COLORS.resort;

        actx.fillRect(el.x, el.y, el.w, el.h);

        // label
        actx.fillStyle = 'rgba(0,0,0,0.5)';
        actx.font = '3px Arial';
        actx.textAlign = 'center';
        actx.fillText(el.label, el.x + el.w/2, el.y + el.h/2);
        actx.textAlign = 'start';

      } else if (el.type === 'park') {
        actx.fillStyle = COLORS.park;
        actx.fillRect(el.x, el.y, el.w, el.h);
        actx.fillStyle = '#15803d';
        const dots = el.details.treeDots || [];
        for (const p of dots) {
          actx.beginPath();
          actx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
          actx.fill();
        }
        // label
        actx.save();
        actx.globalAlpha = 0.55;
        actx.fillStyle = '#065f46';
        actx.font = '3px Arial';
        actx.textAlign = 'center';
        actx.fillText(el.label, el.x + el.w/2, el.y + el.h*0.55);
        actx.restore();
        actx.textAlign = 'start';

      } else if (el.type === 'water') {
        actx.fillStyle = COLORS.water;
        actx.fillRect(el.x, el.y, el.w, el.h);
        actx.strokeStyle = 'rgba(255,255,255,0.55)';
        actx.lineWidth = 0.5;
        for (let i = 0; i < 5; i++) {
          actx.beginPath();
          const waveY = el.y + 10 + (i * 10);
          actx.moveTo(el.x, waveY);
          actx.bezierCurveTo(el.x + el.w / 3, waveY - 5, el.x + 2 * el.w / 3, waveY + 5, el.x + el.w, waveY);
          actx.stroke();
        }
        // label
        actx.save();
        actx.globalAlpha = 0.65;
        actx.fillStyle = '#0c4a6e';
        actx.font = '3px Arial';
        actx.textAlign = 'center';
        actx.fillText(el.label, el.x + el.w/2, el.y + el.h*0.55);
        actx.restore();
        actx.textAlign = 'start';
      }
    });

    actx.restore();
  }

  // --- DRAW LOOP (throttled with rAF) --- 
let needsRedraw = false;

function requestDraw() {
  if (needsRedraw) return;          // already scheduled
  needsRedraw = true;
  requestAnimationFrame(drawFrame);
}

function drawFrame() {
  needsRedraw = false;
  draw();
  drawMiniMap();
}


  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);

    // cached layers
    ctx.drawImage(bufStatic, 0, 0, LAND_WIDTH_M, LAND_HEIGHT_M);
    ctx.drawImage(bufRoads,  0, 0, LAND_WIDTH_M, LAND_HEIGHT_M);
    ctx.drawImage(bufAmen,   0, 0, LAND_WIDTH_M, LAND_HEIGHT_M);
    ctx.drawImage(bufLots,   0, 0, LAND_WIDTH_M, LAND_HEIGHT_M);

    // Hover highlight (lots/mansions/buildings/water/park/roads)
    if (hoveredItem) {
      const el = hoveredItem;

      // hovered fill tint
      if (el.type === 'lot' || el.type === 'mansion') {
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(el.x, el.y, el.w, el.h);
        ctx.restore();
      }

      // outline
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 1;
      if (el.type === 'roundabout') {
        const r = el.w/2;
        ctx.beginPath();
        ctx.arc(el.x + r, el.y + r, r, 0, Math.PI*2);
        ctx.stroke();
      } else {
        ctx.strokeRect(el.x, el.y, el.w, el.h);
      }
    }

    // Pinned selection outlines (max 3)
    pinned.forEach((el, idx) => {
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = idx === 0 ? '#2563eb' : (idx === 1 ? '#7c3aed' : '#16a34a');
      ctx.lineWidth = 1.35;
      ctx.strokeRect(el.x - 0.2, el.y - 0.2, el.w + 0.4, el.h + 0.4);

      // soft glow
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = idx === 0 ? '#2563eb' : (idx === 1 ? '#7c3aed' : '#16a34a');
      ctx.fillRect(el.x, el.y, el.w, el.h);
      ctx.restore();

      // favorite star marker
      if (favorites.has(el.label)) {
        ctx.save();
        ctx.fillStyle = '#f59e0b';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.arc(el.x + el.w - 1.2, el.y + 1.2, 0.9, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    });

    // Labels (only when zoomed)
    if (showLabels && scale >= LABEL_ZOOM_THRESHOLD) {
      ctx.save();
      ctx.fillStyle = 'rgba(15,23,42,0.65)';
      ctx.font = '3.2px Arial';
      ctx.textAlign = 'center';

      for (const el of layoutData) {
        if (el.type === 'lot' || el.type === 'mansion') {
          ctx.fillText(el.label, el.x + el.w/2, el.y + el.h/2);
        }
      }

      ctx.restore();
    }

    // Price labels (only when zoomed)
    if (showPrices && scale >= PRICE_ZOOM_THRESHOLD) {
      ctx.save();
      ctx.font = '3px Arial';
      ctx.textAlign = 'center';
      for (const el of layoutData) {
        if (el.type === 'lot' || el.type === 'mansion') {
          const p = estimatePrice(el);
          const label = `$${fmtMoney(p)}`;
          ctx.fillStyle = 'rgba(255,255,255,0.85)';
          const cx = el.x + el.w/2, cy = el.y + el.h*0.72;
          // label pill (tiny)
          const padW = Math.min(8, el.w*0.55);
          ctx.fillRect(cx - padW/2, cy - 1.8, padW, 3.2);
          ctx.fillStyle = 'rgba(15,23,42,0.8)';
          ctx.fillText(label, cx, cy + 0.6);
        }
      }
      ctx.restore();
    }

    // Car (draggable)
    ctx.save();
    ctx.translate(carPosition.x, carPosition.y);
    ctx.rotate((carPosition.rotation * Math.PI) / 180);
    ctx.fillStyle = COLORS.car;
    const carLen = 4.5;
    const carWid = 1.8;
    ctx.fillRect(-carLen / 2, -carWid / 2, carLen, carWid);
    ctx.fillStyle = '#9ca3af';
    ctx.fillRect(-carLen / 4, -carWid / 2 + 0.2, carLen / 2, carWid - 0.4);
    ctx.restore();

    ctx.restore();
  }

  // --- MINIMAP ---
  let miniDrag = false;

  function getBoundaryBounds() {
    const xs = boundaryPoly.map(p => p[0]);
    const ys = boundaryPoly.map(p => p[1]);
    return { minX: Math.min(...xs), maxX: Math.max(...xs), minY: Math.min(...ys), maxY: Math.max(...ys) };
  }
  const bnds = getBoundaryBounds();

  function worldToMini(x, y, pad=10) {
    const rw = (bnds.maxX - bnds.minX);
    const rh = (bnds.maxY - bnds.minY);
    const s = Math.min((mini.width - pad*2) / rw, (mini.height - pad*2) / rh);
    return {
      x: pad + (x - bnds.minX) * s,
      y: pad + (y - bnds.minY) * s,
      s
    };
  }

  function miniToWorld(mx, my, pad=10) {
    const rw = (bnds.maxX - bnds.minX);
    const rh = (bnds.maxY - bnds.minY);
    const s = Math.min((mini.width - pad*2) / rw, (mini.height - pad*2) / rh);
    return {
      x: bnds.minX + (mx - pad) / s,
      y: bnds.minY + (my - pad) / s
    };
  }

  function drawMiniMap() {
    miniCtx.clearRect(0,0,mini.width, mini.height);

    // background
    miniCtx.fillStyle = 'rgba(248,250,252,1)';
    miniCtx.fillRect(0,0,mini.width, mini.height);

    // boundary
    const pad = 10;
    const pt = worldToMini(BOUNDARY.tl.x, BOUNDARY.tl.y, pad);
    const s = pt.s;

    function w2m(x,y){
      return { x: pad + (x - bnds.minX) * s, y: pad + (y - bnds.minY) * s };
    }

    miniCtx.beginPath();
    const p0 = w2m(BOUNDARY.tl.x, BOUNDARY.tl.y);
    miniCtx.moveTo(p0.x, p0.y);
    [BOUNDARY.tr, BOUNDARY.br, BOUNDARY.bl].forEach(p => {
      const mp = w2m(p.x, p.y);
      miniCtx.lineTo(mp.x, mp.y);
    });
    miniCtx.closePath();
    miniCtx.fillStyle = 'rgba(220,252,231,1)'; // grass-ish
    miniCtx.fill();
    miniCtx.strokeStyle = 'rgba(21,128,61,0.9)';
    miniCtx.lineWidth = 2;
    miniCtx.stroke();

    // simplified roads
    layoutData.forEach(el => {
      if (el.type === 'road') {
        const a = w2m(el.x, el.y);
        const b = w2m(el.x + el.w, el.y + el.h);
        miniCtx.fillStyle = 'rgba(51,65,85,0.55)';
        miniCtx.fillRect(a.x, a.y, b.x - a.x, b.y - a.y);
      }
    });

    // viewport rectangle
    const worldLeft = (-offset.x) / scale;
    const worldTop = (-offset.y) / scale;
    const worldRight = (canvas.width - offset.x) / scale;
    const worldBottom = (canvas.height - offset.y) / scale;

    const v1 = w2m(worldLeft, worldTop);
    const v2 = w2m(worldRight, worldBottom);

    miniCtx.strokeStyle = 'rgba(37,99,235,0.95)';
    miniCtx.lineWidth = 2;
    miniCtx.strokeRect(v1.x, v1.y, v2.x - v1.x, v2.y - v1.y);

    // pinned markers
    pinned.forEach((el, idx) => {
      const c = el.center();
      const mp = w2m(c.x, c.y);
      miniCtx.beginPath();
      miniCtx.fillStyle = idx === 0 ? 'rgba(37,99,235,0.95)' : (idx===1 ? 'rgba(124,58,237,0.95)' : 'rgba(22,163,74,0.95)');
      miniCtx.arc(mp.x, mp.y, 4, 0, Math.PI*2);
      miniCtx.fill();
    });
  }

  mini.addEventListener('mousedown', (e) => {
    miniDrag = true;
    moveViewportFromMini(e);
  });
  window.addEventListener('mousemove', (e) => {
    if (!miniDrag) return;
    moveViewportFromMini(e);
  });
  window.addEventListener('mouseup', () => { miniDrag = false; });

  function moveViewportFromMini(e) {
    const rect = mini.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (mini.width / rect.width);
    const my = (e.clientY - rect.top) * (mini.height / rect.height);
    const wp = miniToWorld(mx, my);

    // center viewport on wp
    const viewW = canvas.width / scale;
    const viewH = canvas.height / scale;

    const targetLeft = wp.x - viewW/2;
    const targetTop  = wp.y - viewH/2;

    offset = {
      x: -targetLeft * scale,
      y: -targetTop * scale
    };
    requestDraw();
  }

  // --- UI: STAT BARS ---
  function statBarHTML({ label, icon, colorClass, value, total }) {
    const percent = Math.round((value / total) * 100);
    const sqm = Math.round(value).toLocaleString();
    return `
      <div>
        <div class="flex justify-between items-end mb-1">
          <span class="text-xs font-medium text-slate-700 flex items-center gap-1.5">
            <i data-lucide="${icon}" class="w-4 h-4"></i> ${label}
          </span>
          <span class="text-xs font-bold text-slate-900">
            ${percent}% <span class="text-slate-400 font-normal">(${sqm} m²)</span>
          </span>
        </div>
        <div class="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
          <div class="h-full ${colorClass}" style="width:${percent}%"></div>
        </div>
      </div>
    `;
  }

  function renderStatsBars() {
    statsBars.innerHTML = [
      statBarHTML({ label: 'Residential (Left)', icon: 'home', colorClass: 'bg-blue-400', value: stats.residential, total: TOTAL_AREA_SQM }),
      statBarHTML({ label: 'Roads & Access', icon: 'map', colorClass: 'bg-slate-600', value: stats.road, total: TOTAL_AREA_SQM }),
      statBarHTML({ label: 'Commercial & Resort', icon: 'building-2', colorClass: 'bg-red-400', value: stats.commercial, total: TOTAL_AREA_SQM }),
      statBarHTML({ label: 'Green & Water', icon: 'trees', colorClass: 'bg-green-400', value: stats.green, total: TOTAL_AREA_SQM }),
      statBarHTML({ label: 'Public/School', icon: 'info', colorClass: 'bg-purple-400', value: stats.public, total: TOTAL_AREA_SQM })
    ].join('');
    lucide.createIcons();
  }

  // --- UI: INSPECTOR ---
  function setInspector(item) {
    if (!item) {
      inspectorFilled.classList.add('hidden');
      inspectorEmpty.classList.remove('hidden');
      return;
    }
    inspectorEmpty.classList.add('hidden');
    inspectorFilled.classList.remove('hidden');

    insName.textContent = item.label;
    insType.textContent = item.type;
    insDim.textContent = `${item.w.toFixed(1)}m x ${item.h.toFixed(1)}m`;
    insArea.textContent = `${(item.w * item.h).toFixed(0)} sqm`;

    // Favorite button state
    const favBtn = document.getElementById('btnToggleFavorite');
    if (favorites.has(item.label)) {
      favBtn.classList.add('bg-amber-50','border-amber-200');
      favBtn.querySelector('i')?.classList.add('text-amber-500');
    } else {
      favBtn.classList.remove('bg-amber-50','border-amber-200');
      favBtn.querySelector('i')?.classList.remove('text-amber-500');
    }

    renderCompareList();
    lucide.createIcons();
  }

  function renderCompareList() {
    if (!pinned.length) {
      compareList.innerHTML = `<div class="text-xs text-slate-400 italic">No pinned lots yet. Click “Pin/Compare”.</div>`;
      return;
    }

    compareList.innerHTML = pinned.map((el, idx) => {
      const price = showPrices ? estimatePrice(el) : estimatePrice(el); // compute anyway for compare
      const badge = idx === 0 ? 'bg-blue-600' : (idx===1 ? 'bg-violet-600' : 'bg-green-600');
      return `
        <div class="p-3 rounded border border-slate-200 bg-white">
          <div class="flex items-start justify-between gap-2">
            <div>
              <div class="flex items-center gap-2">
                <span class="inline-flex items-center justify-center w-6 h-6 rounded ${badge} text-white text-xs font-black">${idx+1}</span>
                <div class="font-bold text-slate-800">${el.label}</div>
              </div>
              <div class="text-xs text-slate-500 mt-1">
                ${el.w.toFixed(1)}m × ${el.h.toFixed(1)}m • ${(el.w*el.h).toFixed(0)} m²
              </div>
              <div class="text-xs text-slate-600 mt-1">
                Est. Price: <span class="font-bold text-slate-900">$${fmtMoney(price)}</span>
              </div>
            </div>
            <button class="btnUnpin p-2 rounded hover:bg-slate-100 text-slate-500" data-label="${el.label}" title="Remove">
              <i data-lucide="x" class="w-4 h-4"></i>
            </button>
          </div>
        </div>
      `;
    }).join('');

    compareList.querySelectorAll('.btnUnpin').forEach(btn => {
      btn.addEventListener('click', () => {
        const label = btn.getAttribute('data-label');
        pinned = pinned.filter(x => x.label !== label);
        persist();
        renderCompareList();
        requestDraw();
      });
    });

    lucide.createIcons();
  }

  // --- UI: FAVORITES ---
  function renderFavorites() {
    const arr = Array.from(favorites);
    if (!arr.length) {
      favoritesEmpty.classList.remove('hidden');
      favoritesList.innerHTML = '';
      return;
    }
    favoritesEmpty.classList.add('hidden');

    favoritesList.innerHTML = arr.sort().map(label => `
      <div class="p-3 rounded border border-slate-200 bg-white flex items-center justify-between gap-3">
        <div class="text-sm font-bold text-slate-800">${label}</div>
        <div class="flex items-center gap-2">
          <button class="btnFocusFav px-2.5 py-1.5 text-xs font-bold rounded bg-slate-900 text-white hover:bg-slate-800" data-label="${label}">
            Focus
          </button>
          <button class="btnRemoveFav p-2 rounded hover:bg-slate-100 text-slate-500" data-label="${label}" title="Remove">
            <i data-lucide="trash-2" class="w-4 h-4"></i>
          </button>
        </div>
      </div>
    `).join('');

    favoritesList.querySelectorAll('.btnRemoveFav').forEach(btn => {
      btn.addEventListener('click', () => {
        favorites.delete(btn.getAttribute('data-label'));
        persist();
        renderFavorites();
        requestDraw();
      });
    });

    favoritesList.querySelectorAll('.btnFocusFav').forEach(btn => {
      btn.addEventListener('click', () => {
        const label = btn.getAttribute('data-label');
        const el = layoutData.find(x => x.label === label);
        if (!el) return;
        focusOnElement(el);
      });
    });

    lucide.createIcons();
  }

  // --- UI: METRICS / WARNINGS ---
  function renderMetricsAndWarnings() {
    const rowHouses = layoutData.filter(x => x.type === 'lot').length;
    const mansions = layoutData.filter(x => x.type === 'mansion').length;

    // road length estimate
    let roadLen = 0;
    layoutData.forEach(el => {
      if (el.type === 'road') {
        roadLen += (el.w > el.h) ? el.w : el.h;
      } else if (el.type === 'roundabout') {
        const r = el.w/2;
        roadLen += (Math.PI * 2 * r) * 0.35; // partial contribution
      }
    });

    // amenity area (non-res)
    let amenityArea = 0;
    layoutData.forEach(el => {
      if (['water','park','building'].includes(el.type) || (el.type === 'road' && el.label === 'Parking')) {
        if (el.details.zoning !== 'road' && el.details.zoning !== 'residential') amenityArea += (el.w * el.h);
        if (el.label === 'Parking') amenityArea += (el.w * el.h);
      }
    });

    mRowHouses.textContent = rowHouses.toLocaleString();
    mMansions.textContent = mansions.toLocaleString();
    mRoadLen.textContent = `${Math.round(roadLen).toLocaleString()} m`;
    mAmenityArea.textContent = `${Math.round(amenityArea).toLocaleString()} m²`;

    if (!warnings.length) {
      mWarnings.innerHTML = `<div class="text-emerald-700 font-semibold">✅ No warnings detected</div>`;
    } else {
      mWarnings.innerHTML = warnings.map(x => `<div class="text-amber-800">${x}</div>`).join('');
    }
  }

  // --- FLOOR PLAN MODAL ---
  function buildRooms(lot) {
    const isMansion = lot.type === 'mansion';
    const w = lot.w, h = lot.h;
    const r = [];

    if (isMansion) {
      const foyerW = w * 0.4, foyerH = h * 0.25;
      r.push({ x: (w - foyerW) / 2, y: h - foyerH, w: foyerW, h: foyerH, name: 'Grand Foyer', color: '#f3e8ff' });
      const greatW = w * 0.5, greatH = h * 0.4;
      r.push({ x: (w - greatW) / 2, y: h - foyerH - greatH, w: greatW, h: greatH, name: 'Great Room', color: '#e9d5ff' });
      r.push({ x: w - (w * 0.3), y: h * 0.3, w: w * 0.3, h: h * 0.7, name: 'Kitchen & Dining', color: '#fce7f3' });
      r.push({ x: 0, y: h * 0.4, w: w * 0.25, h: h * 0.6, name: 'Master Suite', color: '#dbeafe' });
      r.push({ x: 0, y: 0, w: w * 0.4, h: h * 0.4, name: 'Study/Guest', color: '#e0f2fe' });
      r.push({ x: w * 0.4, y: 0, w: w * 0.6, h: h * 0.3, name: 'Terrace', color: '#ecfccb', isOutdoor: true });
    } else {
      const garageW = 3.5, garageH = 6;
      if (w > 6) r.push({ x: 0, y: h - garageH, w: garageW, h: garageH, name: 'Garage', color: '#e5e7eb' });
      const livingW = w - (w > 6 ? garageW : 0);
      r.push({ x: (w > 6 ? garageW : 0), y: h * 0.5, w: livingW, h: h * 0.5, name: 'Living & Dining', color: '#dbeafe' });
      r.push({ x: 0, y: h * 0.25, w: w, h: h * 0.25, name: 'Kitchen', color: '#fae8ff' });
      r.push({ x: 0, y: 0, w: w * 0.5, h: h * 0.25, name: 'Master Bed', color: '#d1fae5' });
      r.push({ x: w * 0.5, y: 0, w: w * 0.5, h: h * 0.25, name: 'Bed 2', color: '#d1fae5' });
    }
    return r;
  }

  function openFloorPlanModal(lot) {
    const isMansion = lot.type === 'mansion';
    const w = lot.w, h = lot.h;
    const maxDim = Math.max(w, h);
    const sc = 300 / maxDim;
    const rooms = buildRooms(lot);

    modalRoot.classList.remove('hidden');
    modalRoot.innerHTML = `
      <div class="absolute inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50 p-4" id="modalBackdrop">
        <div class="bg-white rounded-lg shadow-2xl overflow-hidden max-w-lg w-full flex flex-col max-h-[90vh]">
          <div class="p-4 border-b flex justify-between items-center ${isMansion ? 'bg-purple-50' : 'bg-blue-50'}">
            <div>
              <h3 class="font-bold text-lg ${isMansion ? 'text-purple-900' : 'text-blue-900'}">${lot.label}</h3>
              <p class="text-xs text-gray-500">${w.toFixed(1)}m x ${h.toFixed(1)}m | ${(w*h).toFixed(0)} sqm</p>
            </div>
            <button id="btnCloseX" class="p-2 hover:bg-black/5 rounded-full text-gray-500">
              <i data-lucide="x" class="w-5 h-5"></i>
            </button>
          </div>

          <div class="p-6 overflow-y-auto flex flex-col items-center">
            <div class="relative border-4 border-slate-800 bg-white shadow-lg mb-6" style="width:${w*sc}px;height:${h*sc}px;">
              ${rooms.map((room) => `
                <div class="absolute border border-slate-300 flex items-center justify-center text-center p-1"
                  style="left:${room.x*sc}px;top:${room.y*sc}px;width:${room.w*sc}px;height:${room.h*sc}px;background:${room.color};">
                  <span class="text-[10px] font-medium leading-tight text-slate-700">${room.name}</span>
                </div>
              `).join('')}
              <div class="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-1/2 w-6 h-3 bg-slate-800 rounded-b text-[8px] text-white flex items-center justify-center">
                Entry
              </div>
            </div>

            <div class="grid grid-cols-2 gap-4 w-full text-sm">
              <div class="bg-slate-50 p-3 rounded border border-slate-100">
                <h4 class="font-semibold text-slate-700 mb-2 flex items-center gap-2">
                  <i data-lucide="utensils" class="w-4 h-4"></i> Ground Floor
                </h4>
                <ul class="space-y-1 text-slate-500 text-xs">
                  <li>• Open Concept Living</li>
                  <li>• Modern Kitchen</li>
                  <li>• Dining Area</li>
                  ${isMansion ? `<li>• Grand Foyer</li>` : ``}
                </ul>
              </div>
              <div class="bg-slate-50 p-3 rounded border border-slate-100">
                <h4 class="font-semibold text-slate-700 mb-2 flex items-center gap-2">
                  <i data-lucide="bed-double" class="w-4 h-4"></i> Private Zones
                </h4>
                <ul class="space-y-1 text-slate-500 text-xs">
                  <li>• Master Suite</li>
                  <li>• ${isMansion ? '3' : '2'} Guest Bedrooms</li>
                  <li>• ${isMansion ? '4' : '2.5'} Bathrooms</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="p-4 bg-gray-50 border-t text-center">
            <button id="btnClose" class="px-6 py-2 bg-slate-800 text-white rounded hover:bg-slate-700 text-sm font-medium">
              Close View
            </button>
          </div>
        </div>
      </div>
    `;

    const backdrop = document.getElementById('modalBackdrop');
    const close = () => closeFloorPlanModal();
    backdrop.addEventListener('click', (e) => { if (e.target === backdrop) close(); });
    document.getElementById('btnClose').addEventListener('click', close);
    document.getElementById('btnCloseX').addEventListener('click', close);

    lucide.createIcons();
  }

  function closeFloorPlanModal() {
    modalRoot.classList.add('hidden');
    modalRoot.innerHTML = '';
  }

  // --- STREET VIEW MODE (2.5D) ---
  function getStreetAdjacents(road) {
    // find lots above and below road based on y alignment, inside road x span
    const eps = 2.5;
    const topLots = [];
    const bottomLots = [];
    const mansions = [];

    for (const el of layoutData) {
      if (el.type === 'lot') {
        const withinX = (el.x + el.w) >= road.x && el.x <= (road.x + road.w);
        if (!withinX) continue;

        // top row: el bottom near road.y
        if (Math.abs((el.y + el.h) - road.y) <= eps) topLots.push(el);
        // bottom row: el.y near road.y + road.h
        if (Math.abs(el.y - (road.y + road.h)) <= eps) bottomLots.push(el);
      }
      if (el.type === 'mansion') {
        // mansion roughly aligned to this road y band
        const roadCy = road.y + road.h/2;
        const elCy = el.y + el.h/2;
        if (Math.abs(elCy - roadCy) <= (road.h + 12)) mansions.push(el);
      }
    }

    topLots.sort((a,b) => a.x - b.x);
    bottomLots.sort((a,b) => a.x - b.x);
    mansions.sort((a,b) => a.y - b.y);

    return { topLots, bottomLots, mansions };
  }

  function openStreetView(road) {
    streetViewOpen = true;
    streetViewRoad = road;
    streetViewCarT = 0;

    const { topLots, bottomLots, mansions } = getStreetAdjacents(road);

    const all = [...topLots, ...bottomLots, ...mansions];
    const title = road.label;

    streetViewRoot.classList.remove('hidden');
    streetViewRoot.innerHTML = `
      <div class="absolute inset-0 z-40 bg-black/35 backdrop-blur-sm flex items-end justify-center p-3" id="svBackdrop">
        <div class="w-full max-w-6xl bg-white rounded-2xl shadow-2xl border border-slate-200 overflow-hidden">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex items-center justify-between gap-3">
            <div>
              <div class="text-xs font-bold text-slate-500 uppercase tracking-wider">Street View Mode</div>
              <div class="text-lg font-extrabold text-slate-900 flex items-center gap-2">
                <i data-lucide="car" class="w-5 h-5 text-slate-900"></i> ${title}
              </div>
              <div class="text-xs text-slate-500 mt-1">
                Top row: ${topLots.length} • Bottom row: ${bottomLots.length} • Mansions: ${mansions.length}
              </div>
            </div>

            <div class="flex items-center gap-2">
              <button id="svFocusRoad" class="px-3 py-2 text-xs font-bold rounded bg-white border border-slate-200 hover:bg-slate-100 flex items-center gap-2">
                <i data-lucide="locate-fixed" class="w-4 h-4"></i> Focus on Map
              </button>
              <button id="svClose" class="px-3 py-2 text-xs font-bold rounded bg-slate-900 text-white hover:bg-slate-800 flex items-center gap-2">
                <i data-lucide="x" class="w-4 h-4"></i> Close
              </button>
            </div>
          </div>

          <div class="p-4">
            <div class="sv-persp">
              <!-- top row -->
              <div class="sv-strip flex gap-2 overflow-x-auto pb-3">
                ${topLots.map(el => streetCardHTML(el, 'Top')).join('')}
              </div>

              <!-- road -->
              <div class="sv-road rounded-xl h-16 relative flex items-center justify-center my-3">
                <div class="absolute inset-x-0 top-1/2 -translate-y-1/2 border-t border-dashed border-white/50"></div>
                <div class="text-white/85 text-xs font-bold uppercase tracking-wider">${title}</div>
                <div id="svCar" class="absolute top-1/2 -translate-y-1/2 w-10 h-5 rounded bg-red-500 shadow-lg border border-white/20"></div>
              </div>

              <!-- bottom row -->
              <div class="sv-strip flex gap-2 overflow-x-auto pt-3">
                ${bottomLots.map(el => streetCardHTML(el, 'Bottom')).join('')}
              </div>

              <!-- mansions -->
              <div class="mt-4">
                <div class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">Street-End Mansions</div>
                <div class="flex gap-2 overflow-x-auto">
                  ${mansions.length ? mansions.map(el => streetCardHTML(el, 'Mansion')).join('') : `<div class="text-sm text-slate-400 italic">No mansions detected for this street.</div>`}
                </div>
              </div>
            </div>
          </div>

          <div class="p-4 bg-slate-50 border-t border-slate-200 flex items-center justify-between gap-3">
            <div class="text-xs text-slate-600">
              Click any card to pin/compare. Double-click to open floor plan.
            </div>
            <div class="flex items-center gap-2">
              <button id="svPinAllTop" class="px-3 py-2 text-xs font-bold rounded bg-white border border-slate-200 hover:bg-slate-100">Pin Top #1</button>
              <button id="svPinAllBottom" class="px-3 py-2 text-xs font-bold rounded bg-white border border-slate-200 hover:bg-slate-100">Pin Bottom #1</button>
            </div>
          </div>
        </div>
      </div>
    `;

    // backdrop close on click outside
    const svBackdrop = document.getElementById('svBackdrop');
    svBackdrop.addEventListener('click', (e) => {
      if (e.target === svBackdrop) closeStreetView();
    });

    document.getElementById('svClose').addEventListener('click', closeStreetView);
    document.getElementById('svFocusRoad').addEventListener('click', () => {
      closeStreetView(false);
      focusOnElement(road);
    });

    // card interactions
    streetViewRoot.querySelectorAll('[data-street-card]').forEach(elm => {
      const label = elm.getAttribute('data-label');
      elm.addEventListener('click', () => {
        const obj = layoutData.find(x => x.label === label);
        if (!obj) return;
        pinToggle(obj);
      });
      elm.addEventListener('dblclick', () => {
        const obj = layoutData.find(x => x.label === label);
        if (!obj) return;
        openFloorPlanModal(obj);
      });
    });

    document.getElementById('svPinAllTop').addEventListener('click', () => {
      if (topLots[0]) pinToggle(topLots[0], true);
    });
    document.getElementById('svPinAllBottom').addEventListener('click', () => {
      if (bottomLots[0]) pinToggle(bottomLots[0], true);
    });

    lucide.createIcons();
    requestDraw();
    startStreetViewAnimation();
  }

  function streetCardHTML(el, tag) {
    const price = estimatePrice(el);
    const isFav = favorites.has(el.label);
    const bg = el.type === 'mansion' ? 'bg-violet-50 border-violet-200' : 'bg-blue-50 border-blue-200';
    return `
      <div data-street-card="1" data-label="${el.label}"
        class="sv-card min-w-[220px] p-3 rounded-xl border ${bg} shadow-sm hover:shadow transition cursor-pointer">
        <div class="flex items-start justify-between gap-2">
          <div>
            <div class="text-xs font-bold text-slate-500 uppercase tracking-wider">${tag}</div>
            <div class="text-sm font-extrabold text-slate-900">${el.label}</div>
            <div class="text-xs text-slate-600 mt-1">${el.w.toFixed(1)}m × ${el.h.toFixed(1)}m • ${(el.w*el.h).toFixed(0)}m²</div>
          </div>
          <div class="flex items-center gap-1">
            ${isFav ? `<span class="inline-flex items-center justify-center w-8 h-8 rounded-lg bg-amber-100 border border-amber-200"><i data-lucide="star" class="w-4 h-4 text-amber-600"></i></span>` : ``}
          </div>
        </div>
        <div class="mt-3 flex items-center justify-between">
          <div class="text-xs text-slate-500">Est. Price</div>
          <div class="text-sm font-extrabold text-slate-900">$${fmtMoney(price)}</div>
        </div>
      </div>
    `;
  }

  function closeStreetView(clearRoad = true) {
    streetViewOpen = false;
    if (clearRoad) streetViewRoad = null;
    streetViewRoot.classList.add('hidden');
    streetViewRoot.innerHTML = '';
    requestDraw();
  }

  let svAnimRaf = null;
  function startStreetViewAnimation() {
    if (!streetViewOpen) return;
    const svCar = document.getElementById('svCar');
    if (!svCar) return;

    const animate = () => {
      if (!streetViewOpen) return;
      streetViewCarT = (streetViewCarT + 0.006) % 1;

      // move the little car across the road strip
      const left = 8 + streetViewCarT * 84; // % space inside container
      svCar.style.left = `calc(${left}% - 20px)`;
      svCar.style.transform = `translateY(-50%) skewX(-8deg)`;

      svAnimRaf = requestAnimationFrame(animate);
    };
    if (svAnimRaf) cancelAnimationFrame(svAnimRaf);
    svAnimRaf = requestAnimationFrame(animate);
  }

  // --- FOCUS HELPERS ---
  function focusOnElement(el) {
    // set scale so it’s visible and center it
    const targetScale = Math.max(scale, 2.35);
    const cx = el.x + el.w/2;
    const cy = el.y + el.h/2;

    scale = targetScale;
    offset = {
      x: (canvas.width/2) - (cx * scale),
      y: (canvas.height/2) - (cy * scale)
    };
    requestDraw();
  }

  function fitToBoundary() {
    const pad = 50;
    const bw = (bnds.maxX - bnds.minX);
    const bh = (bnds.maxY - bnds.minY);

    const sx = (canvas.width - pad*2) / bw;
    const sy = (canvas.height - pad*2) / bh;
    scale = Math.min(sx, sy);

    // center
    const cx = bnds.minX + bw/2;
    const cy = bnds.minY + bh/2;
    offset = {
      x: (canvas.width/2) - (cx * scale),
      y: (canvas.height/2) - (cy * scale)
    };
    requestDraw();
  }

  // --- PIN / FAVORITE ---
  function pinToggle(el, forcePin=false) {
    if (!(el.type === 'lot' || el.type === 'mansion')) return;

    const exists = pinned.some(x => x.label === el.label);
    if (exists && !forcePin) {
      pinned = pinned.filter(x => x.label !== el.label);
    } else if (!exists) {
      if (pinned.length >= 3) pinned.pop(); // drop the last
      pinned.unshift(el); // newest as #1
    } else if (exists && forcePin) {
      // keep
    }
    persist();
    renderCompareList();
    requestDraw();
  }

  function favoriteToggle(el) {
    if (!el) return;
    if (favorites.has(el.label)) favorites.delete(el.label);
    else favorites.add(el.label);
    persist();
    renderFavorites();
    setInspector(hoveredItem);
    requestDraw();
  }

  // --- CANVAS EVENTS ---
  function getMouseWorld(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    const worldX = (mouseX - offset.x) / scale;
    const worldY = (mouseY - offset.y) / scale;

    return { rect, scaleX, scaleY, mouseX, mouseY, worldX, worldY };
  }

  canvas.addEventListener('mousedown', (e) => {
    clickStartPos = { x: e.clientX, y: e.clientY };

    const { worldX, worldY } = getMouseWorld(e);
    const distToCar = Math.hypot(worldX - carPosition.x, worldY - carPosition.y);

    if (distToCar < 8) {
      isDraggingCar = true;
      return;
    }

    isPanning = true;
    lastMousePos = { x: e.clientX, y: e.clientY };
  });

  canvas.addEventListener('mousemove', (e) => {
    const { scaleX, scaleY, worldX, worldY } = getMouseWorld(e);

    if (isDraggingCar) {
      carPosition = { ...carPosition, x: worldX, y: worldY };
      requestDraw();
      return;
    }

    if (isPanning) {
      const dx = (e.clientX - lastMousePos.x) * scaleX;
      const dy = (e.clientY - lastMousePos.y) * scaleY;
      offset = { x: offset.x + dx, y: offset.y + dy };
      lastMousePos = { x: e.clientX, y: e.clientY };
      requestDraw();
      return;
    }

    // hover detection (top-most)
    let found = null;
    for (let i = layoutData.length - 1; i >= 0; i--) {
      if (layoutData[i].contains(worldX, worldY)) { found = layoutData[i]; break; }
    }
    hoveredItem = found;

    if (activeTab === 'stats') setInspector(hoveredItem);
    requestDraw();
  });

  function onMouseUp(e) {
    const dx = e.clientX - clickStartPos.x;
    const dy = e.clientY - clickStartPos.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 5 && !isDraggingCar) {
      // Click logic:
      if (hoveredItem) {
        if (hoveredItem.type === 'road' && hoveredItem.label !== 'Parking') {
          // Street View mode
          openStreetView(hoveredItem);
        } else if (hoveredItem.type === 'lot' || hoveredItem.type === 'mansion') {
          // Pin/compare on click
          pinToggle(hoveredItem);
          if (activeTab === 'stats') setInspector(hoveredItem);
        } else {
          // other items do nothing
        }
      }
    }

    isDraggingCar = false;
    isPanning = false;
  }

  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('mouseleave', onMouseUp);

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const newScale = Math.max(0.5, Math.min(10, scale - e.deltaY * 0.005));
    scale = newScale;
    requestDraw();
  }, { passive: false });

  // overlay buttons
  document.getElementById('btnZoomIn').addEventListener('click', () => { scale = scale * 1.2; requestDraw(); });
  document.getElementById('btnZoomOut').addEventListener('click', () => { scale = scale / 1.2; requestDraw(); });
  document.getElementById('btnReset').addEventListener('click', () => { scale = 1.8; offset = { x: 40, y: 40 }; requestDraw(); });
  document.getElementById('btnFitTop').addEventListener('click', fitToBoundary);
  document.getElementById('btnFit').addEventListener('click', fitToBoundary);
  document.getElementById('btnResetView').addEventListener('click', () => { scale = 1.8; offset = {x:40,y:40}; requestDraw(); });

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

    const step = 30;
    if (e.key === 'Escape') {
      closeFloorPlanModal();
      closeStreetView();
      return;
    }
    if (e.key === '+' || e.key === '=') { scale *= 1.1; requestDraw(); return; }
    if (e.key === '-' || e.key === '_') { scale /= 1.1; requestDraw(); return; }
    if (e.key.toLowerCase() === 'f') { fitToBoundary(); return; }
    if (e.key.toLowerCase() === 'r') { scale = 1.8; offset = {x:40,y:40}; requestDraw(); return; }

    // pan
    if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') offset.y += step;
    if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') offset.y -= step;
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') offset.x += step;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') offset.x -= step;
    requestDraw();
  });

  // --- INPUTS / TOGGLES ---
  function renderAmenitiesInputs() {
    const rows = [
      { label: 'Lagoon/Beach', k1: 'waterWidth', k2: 'waterDepth' },
      { label: 'Resort Hotel', k1: 'resortWidth', k2: 'resortDepth' },
      { label: 'Park & Golf', k1: 'parkWidth', k2: 'parkDepth' },
      { label: 'School', k1: 'schoolWidth', k2: 'schoolDepth' },
      { label: 'Mall', k1: 'mallWidth', k2: 'mallDepth' },
      { label: 'Mall Parking', k1: 'mallParkingWidth', k2: 'mallParkingDepth' }
    ];

    amenitiesRows.innerHTML = rows.map(r => `
      <div class="flex flex-col mb-1">
        <label class="text-xs text-slate-500 mb-1">${r.label}</label>
        <div class="flex gap-2">
          <div class="relative flex-1">
            <span class="absolute left-1.5 top-1 text-[10px] text-gray-400">W</span>
            <input type="number" data-key="${r.k1}" value="${config[r.k1]}"
              class="w-full border border-gray-300 rounded pl-4 pr-1 py-1 text-xs focus:border-blue-500 outline-none" />
          </div>
          <div class="relative flex-1">
            <span class="absolute left-1.5 top-1 text-[10px] text-gray-400">L</span>
            <input type="number" data-key="${r.k2}" value="${config[r.k2]}"
              class="w-full border border-gray-300 rounded pl-4 pr-1 py-1 text-xs focus:border-blue-500 outline-none" />
          </div>
        </div>
      </div>
    `).join('');

    amenitiesRows.querySelectorAll('input[data-key]').forEach(inp => {
      inp.addEventListener('input', (e) => {
        const k = e.target.getAttribute('data-key');
        config[k] = Number(e.target.value);
        recomputeAndRedraw(true);
      });
    });
  }

  function bindTopInputs() {
    const keys = [
      'mainRoadWidth','resStreetWidth','resRoundaboutRadius',
      'houseWidth','houseDepth','mansionWidth','mansionDepth'
    ];
    keys.forEach(k => {
      const el = document.getElementById(k);
      el.value = config[k];
      el.addEventListener('input', (e) => {
        config[k] = Number(e.target.value);
        recomputeAndRedraw(true);
      });
    });
  }

  // toggles
  document.getElementById('toggleGrid').addEventListener('change', (e) => {
    showGrid = !!e.target.checked;
    recomputeAndRedraw(true, true); // rebuild caches
    persist();
  });
  document.getElementById('toggleLabels').addEventListener('change', (e) => {
    showLabels = !!e.target.checked;
    requestDraw();
    persist();
  });
  document.getElementById('togglePrices').addEventListener('change', (e) => {
    showPrices = !!e.target.checked;
    requestDraw();
    persist();
  });
  document.getElementById('toggleLegend').addEventListener('change', (e) => {
    showLegend = !!e.target.checked;
    legendBox.classList.toggle('hidden', !showLegend);
    persist();
  });

  // pricing inputs
  const priceBase = document.getElementById('priceBase');
  const priceMansionMult = document.getElementById('priceMansionMult');
  const priceAmenityBonus = document.getElementById('priceAmenityBonus');
  const priceRoadBonus = document.getElementById('priceRoadBonus');
  function bindPricing() {
    const update = () => {
      pricing.basePerSqm = Number(priceBase.value || 0);
      pricing.mansionMult = Number(priceMansionMult.value || 1);
      pricing.amenityBonusMax = Number(priceAmenityBonus.value || 0);
      pricing.roadBonusMax = Number(priceRoadBonus.value || 0);
      requestDraw();
      persist();
      renderCompareList();
    };
    [priceBase, priceMansionMult, priceAmenityBonus, priceRoadBonus].forEach(el => el.addEventListener('input', update));
    document.getElementById('btnResetPricing').addEventListener('click', () => {
      pricing = { basePerSqm: 1500, mansionMult: 1.35, amenityBonusMax: 0.18, roadBonusMax: 0.12 };
      priceBase.value = pricing.basePerSqm;
      priceMansionMult.value = pricing.mansionMult;
      priceAmenityBonus.value = pricing.amenityBonusMax;
      priceRoadBonus.value = pricing.roadBonusMax;
      requestDraw();
      persist();
      renderCompareList();
    });
  }

  // Inspector buttons
  document.getElementById('btnClearSelection').addEventListener('click', () => {
    pinned = [];
    persist();
    renderCompareList();
    requestDraw();
  });

  document.getElementById('btnToggleFavorite').addEventListener('click', () => {
    if (!hoveredItem) return;
    if (!(hoveredItem.type === 'lot' || hoveredItem.type === 'mansion')) return;
    favoriteToggle(hoveredItem);
  });

  document.getElementById('btnPinSelection').addEventListener('click', () => {
    if (!hoveredItem) return;
    pinToggle(hoveredItem);
  });

  document.getElementById('btnOpenFloorplan').addEventListener('click', () => {
    if (!hoveredItem) return;
    if (!(hoveredItem.type === 'lot' || hoveredItem.type === 'mansion')) return;
    openFloorPlanModal(hoveredItem);
  });

  // Favorites clear
  document.getElementById('btnClearFavorites').addEventListener('click', () => {
    favorites = new Set();
    persist();
    renderFavorites();
    requestDraw();
  });

  // Street view hint (no-op, but kept for UX)
  document.getElementById('btnToggleStreetViewHint').addEventListener('click', () => {
    // just a subtle bounce: focus on first residential street if exists
    const road = layoutData.find(x => x.type === 'road' && x.label.startsWith('Residential St'));
    if (road) focusOnElement(road);
  });

  // --- TABS ---
  function setTab(name) {
    activeTab = name;

    tabConfig.classList.toggle('hidden', name !== 'config');
    tabStats.classList.toggle('hidden', name !== 'stats');
    tabShortlist.classList.toggle('hidden', name !== 'shortlist');

    const activeClass = "py-2 text-xs font-semibold rounded flex items-center justify-center gap-2 bg-blue-600 text-white shadow";
    const idleClass = "py-2 text-xs font-semibold rounded flex items-center justify-center gap-2 bg-gray-200 text-gray-600 hover:bg-gray-300";

    btnTabConfig.className = (name === 'config') ? activeClass : idleClass;
    btnTabStats.className = (name === 'stats') ? activeClass : idleClass;
    btnTabShortlist.className = (name === 'shortlist') ? activeClass : idleClass;

    if (name === 'stats') {
      renderStatsBars();
      setInspector(hoveredItem);
      renderMetricsAndWarnings();
    }
    if (name === 'shortlist') {
      renderFavorites();
    }

    lucide.createIcons();
  }
  btnTabConfig.addEventListener('click', () => setTab('config'));
  btnTabStats.addEventListener('click', () => setTab('stats'));
  btnTabShortlist.addEventListener('click', () => setTab('shortlist'));

  // --- EXPORT / IMPORT ---
  document.getElementById('btnExportPNG').addEventListener('click', () => {
    // export main canvas as PNG
    const link = document.createElement('a');
    link.download = 'urban-layout.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  document.getElementById('btnExportJSON').addEventListener('click', () => {
    const payload = exportState();
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'urban-layout.json';
    a.click();
    URL.revokeObjectURL(url);
  });

  document.getElementById('importJSON').addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const payload = JSON.parse(text);
      importState(payload);
    } catch (err) {
      alert('Invalid JSON file.');
    } finally {
      e.target.value = '';
    }
  });

  function exportState() {
    return {
      version: 1,
      config,
      ui: { showGrid, showLabels, showPrices, showLegend },
      view: { scale, offset, carPosition },
      pricing,
      pinned: pinned.map(x => x.label),
      favorites: Array.from(favorites)
    };
  }

  function importState(payload) {
    if (!payload || typeof payload !== 'object') return;
    if (payload.config) config = { ...config, ...payload.config };
    if (payload.ui) {
      showGrid = !!payload.ui.showGrid;
      showLabels = !!payload.ui.showLabels;
      showPrices = !!payload.ui.showPrices;
      showLegend = payload.ui.showLegend !== undefined ? !!payload.ui.showLegend : showLegend;
    }
    if (payload.view) {
      scale = Number(payload.view.scale || scale);
      offset = payload.view.offset || offset;
      carPosition = payload.view.carPosition || carPosition;
    }
    if (payload.pricing) pricing = { ...pricing, ...payload.pricing };
    if (payload.favorites) favorites = new Set(payload.favorites);
    // recompute layout before restoring pinned refs
    recomputeAndRedraw(true, true);
    // restore pinned by label
    if (payload.pinned) {
      pinned = payload.pinned
        .map(lbl => layoutData.find(x => x.label === lbl))
        .filter(Boolean)
        .slice(0,3);
    }

    // update UI inputs
    syncUIFromState();
    persist();
    requestDraw();
    renderFavorites();
    renderCompareList();
    if (activeTab === 'stats') renderMetricsAndWarnings();
  }

  // --- PERSISTENCE ---
  function persist() {
    const payload = exportState();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }

  function restore() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const payload = JSON.parse(raw);
      importState(payload);
    } catch {}
  }

  function syncUIFromState() {
    // toggles
    document.getElementById('toggleGrid').checked = showGrid;
    document.getElementById('toggleLabels').checked = showLabels;
    document.getElementById('togglePrices').checked = showPrices;
    document.getElementById('toggleLegend').checked = showLegend;
    legendBox.classList.toggle('hidden', !showLegend);

    // pricing inputs
    priceBase.value = pricing.basePerSqm;
    priceMansionMult.value = pricing.mansionMult;
    priceAmenityBonus.value = pricing.amenityBonusMax;
    priceRoadBonus.value = pricing.roadBonusMax;

    // dimension inputs
    ['mainRoadWidth','resStreetWidth','resRoundaboutRadius','houseWidth','houseDepth','mansionWidth','mansionDepth'].forEach(k => {
      const el = document.getElementById(k);
      if (el) el.value = config[k];
    });

    renderAmenitiesInputs();
    lucide.createIcons();
  }

  // --- RECOMPUTE PIPELINE ---
  function recomputeAndRedraw(rebuild = false, rebuildStaticToo = false) {
    layoutData = computeLayoutData();
    deriveLayoutMeta();
    stats = computeStats();
    warnings = computeWarnings();

    // rebuild caches whenever geometry changes or grid toggles
    rebuildCaches();

    // update analytics UI if visible
    if (activeTab === 'stats') {
      renderStatsBars();
      renderMetricsAndWarnings();
      setInspector(hoveredItem);
    }

    // refresh favorites view if open
    if (activeTab === 'shortlist') renderFavorites();

    persist();
    requestDraw();
  }

  // --- INIT ---
  function init() {
    initBuffers();
    renderAmenitiesInputs();
    bindTopInputs();
    bindPricing();

    // restore saved state (includes recompute)
    layoutData = computeLayoutData();
    deriveLayoutMeta();
    stats = computeStats();
    warnings = computeWarnings();
    rebuildCaches();
    requestDraw();

    restore(); // will re-import and recompute

    // default UI sync
    syncUIFromState();
    renderFavorites();
    renderCompareList();

    // Fit boundary once (optional)
    // fitToBoundary();

    lucide.createIcons();
  }

  init();
})();
</script>
</body>
</html>
